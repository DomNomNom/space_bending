<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Mesh Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 8px;
    }
  </style>
</head>
<body>
<div id="loading">Loading WASM...</div>
<script src="js/three.min.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js/OrbitControls.js"></script>

<!-- <canvas id="canvas"></canvas> -->
  
<script type="module">
import init, { MeshHandle } from './wasm/pkg/wasm.js';

// Global variables
let scene, camera, renderer, controls;
let meshHandle; // WASM mesh handle
let meshObject; // THREE.js object
let positionAttribute; // Buffer attribute for positions
let wasmMemory; // Reference to WASM memory

let ratio = 1. / 3.;
let size = 10;

let textureSize = 512;

let sizex = ratio > 1. ? size * ratio : size;
let sizey = ratio < 1. ? size / ratio : size;

// Create a proxy object for the constants
const constants = {
    dt: 0.05,
    edgeSpringConstant: 50,
    dihedralSpringConstant: 70,
    dampingCoefficient: 1.5,
    globalDamping: 0.5,
    edgeCoef: 10.0,
    gravityCoef: 0.0,
    iterations: 1
};

const guidata = {
    run_simulation: false,
    scene: "portal1",
};

// Initialize everything
async function init2(texture) {
    try {
        // Load WASM module
        const wasmModule = await init('./wasm/pkg/wasm_bg.wasm');
        wasmMemory = wasmModule.memory;
        
        // Hide loading screen
        document.getElementById('loading').style.display = 'none';
        
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 1;
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(light);
        
        // Create orbit controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // Create the mesh in WASM
        console.log("Creating mesh...");
        meshHandle = new MeshHandle(sizex + 1, sizey + 1);
        createMeshObject(texture);

        for (const name in constants) {
          meshHandle.set_constant(name, constants[name]);
        }
        
        // Set up GUI
        setupGUI();

        // Handle window resize
        window.addEventListener('resize', onWindowResize);
        
        // Start animation loop
        animate();
        
    } catch (error) {
        console.error("Error initializing application:", error);
        document.getElementById('loading').textContent = 
            'Error loading WASM: ' + error.message;
    }
}

// Declare a variable to hold the UV attribute
let uvAttribute;

function createMeshObject(texture) {
    // Remove existing mesh object if any
    if (meshObject) {
        scene.remove(meshObject);
    }
    
    // Create a new geometry and material
    const geometry = new THREE.BufferGeometry();
    // Create a custom shader material with texture support
    const material = new THREE.ShaderMaterial({
      uniforms: {
        baseTexture: { value: texture }, // Your existing texture
        darknessFactor: { value: 0.5 }   // How much to darken at maximum angle
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec2 vUv;
        
        void main() {
          // Pass the UV coordinates to the fragment shader
          vUv = uv;
          
          // Pass the normal to the fragment shader
          vNormal = normalize(normalMatrix * normal);
          
          // Calculate view position
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vViewPosition = -mvPosition.xyz;
          
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform sampler2D baseTexture;
        uniform float darknessFactor;
        
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        varying vec2 vUv;
        
        void main() {
          // Sample the texture using UV coordinates
          vec4 texColor = texture2D(baseTexture, vUv);
          
          // Normalize the view direction
          vec3 viewDir = normalize(vViewPosition);
          
          // Calculate the dot product between normal and view direction
          float dotNV = max(0.0, abs(dot(vNormal, viewDir)));
          
          // Calculate darkness based on the angle
          float darkness = (1.0 - dotNV) * darknessFactor;
          
          // Apply darkness to the texture color
          vec3 finalColor = texColor.rgb * (1.0 - darkness);
          
          gl_FragColor = vec4(finalColor, texColor.a);
        }
      `,
      side: THREE.DoubleSide
    });
    
    // Get triangle count from WASM
    const triangleCount = meshHandle.get_triangle_count();
    const vertexCount = triangleCount * 3; // 3 vertices per triangle
    
    // Create a view into the WASM memory for positions
    const triangleDataPtr = meshHandle.get_triangle_buffer();
    const triangleData = new Float32Array(
        wasmMemory.buffer, 
        triangleDataPtr, 
        vertexCount * 3  // 3 coordinates per vertex
    );
    
    // Get UV coordinates from WASM
    const uvDataPtr = meshHandle.get_uv_buffer();
    const uvData = new Float32Array(
        wasmMemory.buffer,
        uvDataPtr,
        vertexCount * 2  // 2 coordinates (u, v) per vertex
    );
    
    // Important! We need to copy the data since the WASM memory may move
    // if it gets resized
    const triangleDataCopy = new Float32Array(triangleData);
    const uvDataCopy = new Float32Array(uvData);
    
    // Create and store the position attribute
    positionAttribute = new THREE.BufferAttribute(triangleDataCopy, 3);
    geometry.setAttribute('position', positionAttribute);
    
    // Create and store the UV attribute
    uvAttribute = new THREE.BufferAttribute(uvDataCopy, 2);
    geometry.setAttribute('uv', uvAttribute);
    
    // Compute normals for proper lighting
    geometry.computeVertexNormals();
    
    // Create the mesh object and add it to the scene
    meshObject = new THREE.Mesh(geometry, material);
    scene.add(meshObject);
}

function updateMeshObject() {
    try {
        // Get the latest triangle data from WASM
        const triangleCount = meshHandle.get_triangle_count();
        const vertexCount = triangleCount * 3;
        const triangleDataPtr = meshHandle.get_triangle_buffer();
        
        // Create a new view into WASM memory for positions
        const triangleData = new Float32Array(
            wasmMemory.buffer, 
            triangleDataPtr, 
            vertexCount * 3
        );
        
        // Get latest UV data
        const uvDataPtr = meshHandle.get_uv_buffer();
        const uvData = new Float32Array(
            wasmMemory.buffer,
            uvDataPtr,
            vertexCount * 2
        );
        
        // Update the position attribute with new data
        for (let i = 0; i < triangleData.length; i++) {
            positionAttribute.array[i] = triangleData[i];
        }
        
        // Update the UV attribute
        for (let i = 0; i < uvData.length; i++) {
            uvAttribute.array[i] = uvData[i];
        }
        
        // Mark the attributes as needing an update
        positionAttribute.needsUpdate = true;
        uvAttribute.needsUpdate = true;
        
        // Update the texture if canvas has changed
        texture.needsUpdate = true;
        
        // Compute normals for proper lighting
        meshObject.geometry.computeVertexNormals();
    } catch (error) {
        console.error("Error updating mesh:", error);
    }
}

function setupGUI() {
    const gui = new dat.GUI();

    gui.add(guidata, "run_simulation");
    gui.add(guidata, "scene", [
        "portal1",
        "portal2",
        "portal3",
        "portal4",
        "cylinder",
        "torus",
        "mobius_strip",
    ]).onChange(value => {
        console.log(value);
    });

    const gui2 = gui.addFolder("Params");
    gui2.close();
    
    // Add controls for each constant
    for (const name in constants) {
        const value = constants[name];
        
        // Different ranges based on parameter
        let min, max, step;
        
        if (name === "iterations") {
            min = 1;
            max = 10;
            step = 1;
        } else if (name === 'edgeSpringConstant' || name === 'dihedralSpringConstant') {
            min = 0;
            max = 100;
            step = 0.1;
        } else if (name === 'edgeCoef' || name === 'gravityCoef') {
            min = 0;
            max = 300;
            step = 0.1;
        } else {
            min = 0;
            max = 1;
            step = 0.01;
        }
        
        gui2.add(constants, name).onChange(value => {
            if (name != "iterations") {
                // Forward the change to WASM
                meshHandle.set_constant(name, value);
            }
        });
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    
    try {
        if (guidata.run_simulation) {
            // Step the physics simulation in WASM
            for (let i = 0; i < constants.iterations; i++) {
                meshHandle.step();
            }
            updateMeshObject();
        }
        
        // Update controls and render
        controls.update();
        renderer.render(scene, camera);
    } catch (error) {
        console.error("Error in animation loop:", error);
    }
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

// TextureCreator class for creating and manipulating textures for three.js
class TextureCreator {
  constructor() {
    this.canvas = null;
    this.ctx = null;
    this.width = 0;
    this.height = 0;
    this.imageData = null;
  }

  /**
   * Initialize texture with specific dimensions
   * @param {number} w - Width of the texture
   * @param {number} h - Height of the texture
   */
  init(w, h) {
    this.width = w;
    this.height = h;
    this.size = Math.min(w, h);
    
    // Create canvas if it doesn't exist
    if (!this.canvas) {
      this.canvas = document.createElement('canvas');
      // this.canvas = document.getElementById('canvas');
    }
    
    this.canvas.width = w;
    this.canvas.height = h;
    this.ctx = this.canvas.getContext('2d');
    
    // Clear canvas
    this.ctx.clearRect(0, 0, w, h);
    
    // Create initial imageData
    this.imageData = this.ctx.getImageData(0, 0, w, h);
  }

  /**
   * Draw on the texture using a function that returns RGBA values
   * @param {Function} func - Function that takes (x, y) and returns [r, g, b, a]
   */
  draw(func) {
    const data = this.imageData.data;
    
    // 2x2 subpixel grid offsets for antialiasing
    const subpixelOffsets = [
      [0.25, 0.25], // top-left
      [0.75, 0.25], // top-right
      [0.25, 0.75], // bottom-left
      [0.75, 0.75]  // bottom-right
    ];
    
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        // Calculate index in the image data array
        const idx = (y * this.width + x) * 4;
        
        // Sample 4 subpixels and average them
        let sumR = 0, sumG = 0, sumB = 0, sumA = 0;
        
        for (const [offX, offY] of subpixelOffsets) {
          // Normalize coordinates to 0-1 range with subpixel offset
          const nx = (x + offX) / this.size;
          const ny = (y + offY) / this.size;
          
          // Get rgba values from the function (0-255 range)
          const [r, g, b, a] = func(nx, ny);
          
          // Convert alpha to 0-1 range
          const alpha = a / 255;
          
          // Accumulate values (premultiplied by alpha)
          sumR += r * alpha;
          sumG += g * alpha;
          sumB += b * alpha;
          sumA += alpha;
        }
        
        // Average the accumulated values
        sumR /= 4;
        sumG /= 4;
        sumB /= 4;
        sumA /= 4;
        
        // Get current pixel values
        const dstR = data[idx];
        const dstG = data[idx + 1];
        const dstB = data[idx + 2];
        const dstA = data[idx + 3] / 255;
        
        // Apply standard alpha blending
        const outA = sumA + dstA * (1 - sumA);
        
        if (outA > 0) {
          data[idx] = (sumR + dstR * dstA * (1 - sumA)) / outA;
          data[idx + 1] = (sumG + dstG * dstA * (1 - sumA)) / outA;
          data[idx + 2] = (sumB + dstB * dstA * (1 - sumA)) / outA;
        } else {
          data[idx] = 0;
          data[idx + 1] = 0;
          data[idx + 2] = 0;
        }
        
        data[idx + 3] = Math.round(outA * 255);
      }
    }
    
    // Put the modified image data back to the canvas
    this.ctx.putImageData(this.imageData, 0, 0);
  }

  /**
   * Return the texture in a format compatible with three.js
   * @returns {THREE.Texture} - three.js texture
   */
  getTexture() {
    const texture = new THREE.CanvasTexture(this.canvas);
    texture.needsUpdate = true;
    return texture;
  }

  /**
   * Draw a circle at specified position with given radius and color
   * @param {number} cx - Center x-coordinate (0-1)
   * @param {number} cy - Center y-coordinate (0-1)
   * @param {number} radius - Radius (0-1)
   * @param {Array} color - [r, g, b, a] color values (0-255)
   */
  drawCircle(cx, cy, radius, color) {
    this.draw((x, y) => {
      // Calculate distance from center
      const dx = x - cx;
      const dy = y - cy;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // If inside circle, return the color
      if (distance <= radius) {
        return color;
      }
      
      // Otherwise, return transparent
      return [0, 0, 0, 0];
    });
  }

  /**
   * Draw a line between two points with specified thickness
   * @param {number} x1 - Start x-coordinate (0-1)
   * @param {number} y1 - Start y-coordinate (0-1)
   * @param {number} x2 - End x-coordinate (0-1)
   * @param {number} y2 - End y-coordinate (0-1)
   * @param {number} thickness - Line thickness (0-1)
   * @param {Array} color - [r, g, b, a] color values (0-255)
   */
  drawLine(x1, y1, x2, y2, thickness, color) {
    this.draw((x, y) => {
      // Line SDF (Signed Distance Function)
      // Calculate distance from point to line segment
      const a = { x: x1, y: y1 };
      const b = { x: x2, y: y2 };
      const p = { x, y };
      
      const ab = { x: b.x - a.x, y: b.y - a.y };
      const ap = { x: p.x - a.x, y: p.y - a.y };
      
      const lenSq = ab.x * ab.x + ab.y * ab.y;
      const dot = ap.x * ab.x + ap.y * ab.y;
      let t = Math.max(0, Math.min(1, dot / lenSq));
      
      const closest = {
        x: a.x + ab.x * t,
        y: a.y + ab.y * t
      };
      
      const dx = x - closest.x;
      const dy = y - closest.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // If inside the line (distance less than half the thickness)
      if (distance <= thickness / 2) {
        return color;
      }
      
      // Otherwise, return transparent
      return [0, 0, 0, 0];
    });
  }

  /**
   * Draw a rotated square at specified position with given side size and rotation
   * @param {number} cx - Center x-coordinate (0-1)
   * @param {number} cy - Center y-coordinate (0-1)
   * @param {number} size - Side size (0-1)
   * @param {number} angle - Rotation angle in radians
   * @param {Array} color - [r, g, b, a] color values (0-255)
   */
  drawRotatedSquare(cx, cy, size, angle, color, discard) {
    this.draw((x, y) => {
      if (discard(x, y)) return [0, 0, 0, 0];

      // Translate to origin
      const dx = x - cx;
      const dy = y - cy;
      
      // Rotate
      const cos = Math.cos(-angle);
      const sin = Math.sin(-angle);
      const rx = dx * cos - dy * sin;
      const ry = dx * sin + dy * cos;
      
      // Half size for easier calculation
      const halfSize = size / 2;
      
      // If inside square
      if (Math.abs(rx) <= halfSize && Math.abs(ry) <= halfSize) {
        return color;
      }
      
      // Otherwise, return transparent
      return [0, 0, 0, 0];
    });
  }

  /**
   * Draw an infinite checkerboard pattern
   * @param {number} tileSize - Size of each tile (0-1)
   * @param {Array} color1 - First color [r, g, b, a] (0-255)
   * @param {Array} color2 - Second color [r, g, b, a] (0-255)
   */
  drawCheckerboard(tileSize, color1, color2) {
    this.draw((x, y) => {
      // Scale coordinates to create tiles of the specified size
      const tiledX = Math.floor(x / tileSize);
      const tiledY = Math.floor(y / tileSize);
      
      // Determine if this tile should be color1 or color2
      const isEven = (tiledX + tiledY) % 2 === 0;
      
      return isEven ? color1 : color2;
    });
  }
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

let blueX = 0.2;
let orangeX = 0.8;
let startY = 0.4;
let endY = 0.6;

let thickness = 0.005;

let noDiscard = (x, y) => { return false; };
let discardBlueLeft = (x, y) => { return x > blueX; };
let discardBlueRight = (x, y) => { return x < blueX; };
let discardOrangeLeft = (x, y) => { return x > orangeX; };
let discardOrangeRight = (x, y) => { return x < orangeX; };

// Usage example:
// Create and initialize texture
const textureCreator = new TextureCreator();

textureCreator.init(
    ratio > 1. ? textureSize * ratio : textureSize,
    ratio < 1. ? textureSize / ratio : textureSize,
);

textureCreator.drawCheckerboard(0.1, [255, 255, 255, 255], [255, 255, 255, 255]);
// textureCreator.drawCheckerboard(0.1, [255, 255, 255, 20], [0, 0, 0, 20]);
textureCreator.drawCheckerboard(1. / sizex, [255, 255, 255, 40], [0, 0, 0, 40]);

// textureCreator.drawRotatedSquare(0.4, 0.1, 0.2, 0.2, [0, 0, 0, 192], noDiscard);
// textureCreator.drawLine(0.1, 0.9, 0.9, 0.7, 0.05, [255, 128, 255, 192]);

let sq1Size = 0.1;
let sq1Angle = Math.PI/4;
let sq1Color = [0, 255, 0, 192];
textureCreator.drawRotatedSquare(blueX, (startY + endY) / 2., sq1Size, sq1Angle, sq1Color, discardBlueLeft);
textureCreator.drawRotatedSquare(orangeX, (startY + endY) / 2., sq1Size, sq1Angle, sq1Color, discardOrangeRight);

let sq2Size = 0.09;
let sq2Angle = Math.PI/3;
let sq2Color = [128, 128, 255, 192];
textureCreator.drawRotatedSquare(blueX-0.02, (startY + endY) / 2. + 0.01, sq2Size, sq2Angle, sq2Color, discardBlueRight);
textureCreator.drawRotatedSquare(orangeX-0.02, (startY + endY) / 2. + 0.01, sq2Size, sq2Angle, sq2Color, discardOrangeLeft);

let blue = [9, 164, 201, 255];
textureCreator.drawCircle(blueX, startY, thickness * 1.5, blue);
textureCreator.drawCircle(blueX, endY, thickness * 1.5, blue);
textureCreator.drawLine(blueX, startY, blueX, endY, thickness, blue);

let orange = [237, 108, 13, 255];
textureCreator.drawCircle(orangeX, startY, thickness * 1.5, orange);
textureCreator.drawCircle(orangeX, endY, thickness * 1.5, orange);
textureCreator.drawLine(orangeX, startY, orangeX, endY, thickness, orange);

const texture = textureCreator.getTexture();

// Start the application
init2(texture).catch(console.error);
</script>
</body>
</html>
