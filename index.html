<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Mesh Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #stepButton {
      position: absolute;
      bottom: 10px;
      left: 10px;
      padding: 8px 16px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #stepButton:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
<button id="stepButton">Step</button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
<script>
// Vector3 utility class for 3D vector operations
class Vector3 {
  constructor(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }
  
  add(v) {
    return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
  }
  
  sub(v) {
    return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
  }
  
  multiply(s) {
    return new Vector3(this.x * s, this.y * s, this.z * s);
  }
  
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  
  cross(v) {
    return new Vector3(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x
    );
  }
  
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  
  normalize() {
    const len = this.length();
    if (len === 0) return new Vector3(0, 0, 0);
    return new Vector3(this.x / len, this.y / len, this.z / len);
  }
  
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
}

// Particle class for mass-spring system
class Particle {
  constructor(x, y, z) {
    this.position = new Vector3(x, y, z);
    this.velocity = new Vector3(0, 0, 0);
    this.force = new Vector3(0, 0, 0);
  }
}

// Edge spring for maintaining distances between particles
class EdgeSpring {
  constructor(i, j, restLength, edge=false) {
    this.i = i; // Index of first particle
    this.j = j; // Index of second particle
    this.restLength = restLength;
    this.edge = edge;
  }
}

// Dihedral spring for resisting bending
class DihedralSpring {
  constructor(i1, i2, i3, i4, edge=false) {
    this.i1 = i1; // First edge point
    this.i2 = i2; // Second edge point
    this.i3 = i3; // First wing point (from triangle 1)
    this.i4 = i4; // Second wing point (from triangle 2)
    this.edge = edge;
  }
}

// Triangle for mesh representation
class Triangle {
  constructor(i, j, k) {
    this.indices = [i, j, k]; // Indices of three particles
  }
}

function dihedralSpring(p1, p2, p3, p4, k) {
  // k is the stiffness constant

  // 1. Hinge axis and midpoint.
  const hinge = p2.sub(p1);
  const axis = hinge.clone().normalize();
  const mid = p1.add(p2).multiply(0.5);
  
  // 2. Compute wing vectors (from hinge midpoint) and project onto plane perpendicular to the hinge.
  const v3 = p3.sub(mid);
  const v4 = p4.sub(mid);
  const v3_proj = v3.sub(axis.clone().multiply(v3.dot(axis)));
  const v4_proj = v4.sub(axis.clone().multiply(v4.dot(axis)));
  
  // Avoid division by (almost) zero if either projection is too short.
  if (v3_proj.length() < 1e-6 || v4_proj.length() < 1e-6) {
    return [
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0),
      new Vector3(0, 0, 0)
    ];
  }
  
  // 3. When flat, v3_proj and v4_proj should be oppositely directed.
  // Their sum (misalignment) is our measure of how far we are from 180°.
  const misalignment = v3_proj.add(v4_proj);
  
  // 4. Compute force on each wing (p3 and p4) so that only the component perpendicular
  //    to its own projection is applied (to cause a rotation rather than a translation).
  //    That is, we remove the part of misalignment that is parallel to the wing’s projection.
  function computeWingForce(v_proj) {
    // Component of misalignment parallel to v_proj:
    const parallel = v_proj.clone().multiply(v_proj.dot(misalignment) / (v_proj.length() ** 2));
    // The perpendicular part is what we use to “rotate” the wing.
    return misalignment.clone().sub(parallel).multiply(-k);
  }
  
  const F3 = computeWingForce(v3_proj);
  const F4 = computeWingForce(v4_proj);
  
  // 5. For momentum conservation, the reaction forces on the common edge are taken as the
  //    negative of the sum of F3 and F4. Here we split that equally between p1 and p2.
  const hingeForce = F3.add(F4).multiply(-0.5);
  const F1 = hingeForce.clone();
  const F2 = hingeForce.clone();
  
  // Return the forces [force on p1, force on p2, force on p3, force on p4].
  return [F1, F2, F3, F4];
}

function calcForces(particles, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, gravityCoef) {
  // Apply edge spring forces
  for (let i = 0; i < edgeSprings.length; i++) {
    const spring = edgeSprings[i];
    const p1 = particles[spring.i];
    const p2 = particles[spring.j];
    
    const delta = p2.position.sub(p1.position);
    const currentLength = delta.length();
    
    if (currentLength === 0) continue; // Avoid division by zero
    
    const direction = delta.multiply(1 / currentLength);
    
    // Calculate relative velocity along spring direction
    const v1 = p1.velocity;
    const v2 = p2.velocity;
    const relativeVelocity = v2.sub(v1).dot(direction);
    
    // Spring force (Hooke's law with damping)
    const springForce = edgeK * (currentLength - spring.restLength);
    const dampingForce = damping * relativeVelocity;
    let totalForce = springForce + dampingForce;

    if (spring.edge) {
      totalForce = totalForce * edgeCoef;
    }
    
    const forceVector = direction.multiply(totalForce);
    
    p1.force = p1.force.add(forceVector);
    p2.force = p2.force.sub(forceVector);
  }

  for (let i = 0; i < dihedralSprings.length; i++) {
    const spring = dihedralSprings[i];
    const p1 = particles[spring.i1]; // First edge point
    const p2 = particles[spring.i2]; // Second edge point
    const p3 = particles[spring.i3]; // First wing point
    const p4 = particles[spring.i4]; // Second wing point

    let [f1, f2, f3, f4] = dihedralSpring(p1.position, p2.position, p3.position, p4.position, dihedralK);

    let toMul = 1.;
    if (spring.edge) {
      toMul = edgeCoef;
    }

    p1.force = p1.force.add(f1.multiply(toMul));
    p2.force = p2.force.add(f2.multiply(toMul));
    p3.force = p3.force.add(f3.multiply(toMul));
    p4.force = p4.force.add(f4.multiply(toMul));
  }

  // for (let i = 0; i < particles.length; i++) {
  //   for (let j = 0; j < i; j++) {
  //     const p1 = particles[i];
  //     const p2 = particles[j];
  //     let dir = p1.position.sub(p2.position);
  //     let dirLen = dir.length();
  //     dir = dir.normalize().multiply(1. / (dirLen) * gravityCoef * 0.0001);
  //     // dir = dir.normalize().multiply(gravityCoef * 0.001);
  //     p1.force = p1.force.add(dir);
  //     p2.force = p2.force.add(dir.multiply(-1.));
  //   }
  // }
}

// Main Mesh class
class Mesh {
  constructor() {
    // Initialize data structures
    this.particles = [];
    this.edgeSprings = [];
    this.dihedralSprings = [];
    this.triangles = [];
    
    // Simulation constants
    this.constants = {
      dt: 0.1,                    // Time step
      edgeSpringConstant: 10,    // Stiffness for edge springs
      dihedralSpringConstant: 10, // Stiffness for bending resistance
      dampingCoefficient: 0.5,     // Spring damping
      globalDamping: 0.05,         // Velocity damping
      edgeCoef: 1.0,
      gravityCoef: 1.0
    };
  }
  
  // Initialize the mesh as a 2D sheet with size x size points
  init(size) {
    // Clear existing data
    this.particles = [];
    this.edgeSprings = [];
    this.dihedralSprings = [];
    this.triangles = [];
    this.size = size;
    
    // Create particles in a grid
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        const x = i / (size - 1);
        // const y = j / (size - 1) * 10.;
        const y = j / (size - 1);
        const z = 0; // Flat sheet in XY plane
        this.particles.push(new Particle(x, y, z));
      }
    }
    
    // Helper function to get index from grid coordinates
    const getIndex = (i, j) => i * size + j;
    
    // Create edge springs and triangles
    for (let i = 0; i < size - 1; i++) {
      for (let j = 0; j < size - 1; j++) {
        const idx00 = getIndex(i, j);
        const idx01 = getIndex(i, j + 1);
        const idx10 = getIndex(i + 1, j);
        const idx11 = getIndex(i + 1, j + 1);
        
        // Get positions
        const p00 = this.particles[idx00].position;
        const p01 = this.particles[idx01].position;
        const p10 = this.particles[idx10].position;
        const p11 = this.particles[idx11].position;
        
        // Create horizontal edge springs
        const restLengthH = p01.sub(p00).length();
        this.edgeSprings.push(new EdgeSpring(idx00, idx01, restLengthH));
        
        // Create vertical edge springs
        const restLengthV = p10.sub(p00).length();
        this.edgeSprings.push(new EdgeSpring(idx00, idx10, restLengthV));
        
        // Bottom edge springs (for last row/column)
        if (i === size - 2) {
          const restLengthBottom = p11.sub(p10).length();
          this.edgeSprings.push(new EdgeSpring(idx10, idx11, restLengthBottom));
        }
        
        if (j === size - 2) {
          const restLengthRight = p11.sub(p01).length();
          this.edgeSprings.push(new EdgeSpring(idx01, idx11, restLengthRight));
        }
        
        // Create diagonal springs (for stability)
        const restLengthD1 = p11.sub(p00).length();
        this.edgeSprings.push(new EdgeSpring(idx00, idx11, restLengthD1));
        
        const restLengthD2 = p10.sub(p01).length();
        this.edgeSprings.push(new EdgeSpring(idx01, idx10, restLengthD2));
        
        // Create triangles
        this.triangles.push(new Triangle(idx00, idx01, idx10));
        this.triangles.push(new Triangle(idx01, idx11, idx10));
      }
    }
    
    // Create dihedral springs for internal edges
    // Map to track edges and their adjacent triangles
    const edgeToTriangles = new Map();
    
    // Helper function to create a unique key for an edge
    const getEdgeKey = (i, j) => i < j ? `${i}-${j}` : `${j}-${i}`;
    
    // Register all triangle edges
    for (let t = 0; t < this.triangles.length; t++) {
      const triangle = this.triangles[t];
      
      // For each edge in the triangle
      for (let e = 0; e < 3; e++) {
        const i = triangle.indices[e];
        const j = triangle.indices[(e + 1) % 3];
        const edgeKey = getEdgeKey(i, j);
        
        // Find the non-edge vertex of this triangle
        const k = triangle.indices[(e + 2) % 3];
        
        if (!edgeToTriangles.has(edgeKey)) {
          edgeToTriangles.set(edgeKey, { triangles: [], vertices: [] });
        }
        
        const entry = edgeToTriangles.get(edgeKey);
        entry.triangles.push(t);
        entry.vertices.push(k);
      }
    }
    
    // Create dihedral springs for edges shared by two triangles
    for (const [edgeKey, entry] of edgeToTriangles.entries()) {
      if (entry.triangles.length === 2) {
        // This edge is shared by two triangles - create a dihedral spring
        const [i, j] = edgeKey.split('-').map(Number);
        const [v1, v2] = entry.vertices;
        
        this.dihedralSprings.push(new DihedralSpring(i, j, v1, v2));
      }
    }

    for (let i = 0; i < size; i++) {
      this.particles[i].position.z += 0.1;
    }

    // this.edgeSprings.push(new EdgeSpring(getIndex(0, 0), getIndex(size-1, size-1), 0.0, true));
    // this.edgeSprings.push(new EdgeSpring(getIndex(0, size-1), getIndex(size-1, 0), 0.0, true));
    // this.edgeSprings.push(new EdgeSpring(getIndex(0, 0), getIndex(0, size-1), 0.0, true));
    // this.edgeSprings.push(new EdgeSpring(getIndex(size-1, size-1), getIndex(size-1, 0), 0.0, true));

    let blueX = size * 0.2;
    let orangeX = size * 0.8;
    let startY = size * 0.4;
    let endY = size * 0.6;
    for (let i = startY; i <= endY; i++) {
      this.edgeSprings.push(new EdgeSpring(getIndex(blueX, i), getIndex(orangeX, endY+startY - i), 0.0, true));
    }
    for (let i = startY; i <= endY - 1; i++) {
      this.dihedralSprings.push(new DihedralSpring(
        getIndex(blueX, i),
        getIndex(blueX, i+1),
        getIndex(blueX+1, i+1),
        getIndex(orangeX-1, endY+startY - i),
        true
      ));
      this.dihedralSprings.push(new DihedralSpring(
        getIndex(blueX, i),
        getIndex(blueX, i+1),
        getIndex(blueX-1, i+1),
        getIndex(orangeX+1, endY+startY - i),
        true
      ));
    }

    // for (let i = 0; i < size; i++) {
    //   this.edgeSprings.push(new EdgeSpring(getIndex(0, i), getIndex(size-1, i), 0.0, true));
    //   this.edgeSprings.push(new EdgeSpring(getIndex(i, 0), getIndex(i, size-1), 0.0, true));
    // }
    // for (let i = 0; i < size - 1; i++) {
    //   this.dihedralSprings.push(new DihedralSpring(
    //     getIndex(0, i),
    //     getIndex(0, i+1),
    //     getIndex(1, i+1),
    //     getIndex(size-2, i),
    //     true
    //   ));
    //   this.dihedralSprings.push(new DihedralSpring(
    //     getIndex(i, 0),
    //     getIndex(i+1, 0),
    //     getIndex(i+1, 1),
    //     getIndex(i, size-2),
    //     true
    //   ));
    // }
  }
  
  // Perform one simulation step
  step() {
    const dt = this.constants.dt;
    const edgeK = this.constants.edgeSpringConstant;
    const dihedralK = this.constants.dihedralSpringConstant;
    const damping = this.constants.dampingCoefficient;
    const globalDamping = this.constants.globalDamping;
    const edgeCoef = this.constants.edgeCoef;
    const gravityCoef = this.constants.gravityCoef;
    
    // For each iteration (multiple iterations improve stability)
    this.integrateRK4(
      this.particles, 
      dt, 
      calcForces, 
      this.edgeSprings, 
      this.dihedralSprings, 
      edgeK, 
      dihedralK, 
      damping, 
      edgeCoef, 
      globalDamping,
      gravityCoef
    );

    return true;
  }

  // Runge-Kutta 4 integration for the particle system
  integrateRK4(particles, dt, calcForces, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, globalDamping, gravityCoef) {
    // Store original state to return to after evaluations
    const originalStates = particles.map(p => ({
      position: p.position.clone(),
      velocity: p.velocity.clone()
    }));
    
    // Arrays to store the 4 evaluations (k1, k2, k3, k4)
    const k1 = new Array(particles.length);
    const k2 = new Array(particles.length);
    const k3 = new Array(particles.length);
    const k4 = new Array(particles.length);
    
    // STEP 1: First evaluation (k1) at the current state
    this.evaluateDerivatives(particles, k1, calcForces, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, globalDamping, gravityCoef);
    
    // STEP 2: Second evaluation (k2) at t + dt/2 using k1
    this.applyDerivativesHalfStep(particles, k1, dt/2, originalStates);
    this.evaluateDerivatives(particles, k2, calcForces, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, globalDamping, gravityCoef);
    
    // STEP 3: Third evaluation (k3) at t + dt/2 using k2
    this.restoreOriginalState(particles, originalStates);
    this.applyDerivativesHalfStep(particles, k2, dt/2, originalStates);
    this.evaluateDerivatives(particles, k3, calcForces, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, globalDamping, gravityCoef);
    
    // STEP 4: Fourth evaluation (k4) at t + dt using k3
    this.restoreOriginalState(particles, originalStates);
    this.applyDerivativesFullStep(particles, k3, dt, originalStates);
    this.evaluateDerivatives(particles, k4, calcForces, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, globalDamping, gravityCoef);
    
    // Restore to original state before final update
    this.restoreOriginalState(particles, originalStates);
    
    // STEP 5: Combine the derivatives with the RK4 weights (1/6, 2/6, 2/6, 1/6)
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      
      // Update position: x(t+dt) = x(t) + dt/6 * (k1p + 2*k2p + 2*k3p + k4p)
      const positionChange = k1[i].positionDerivative.multiply(1)
        .add(k2[i].positionDerivative.multiply(2))
        .add(k3[i].positionDerivative.multiply(2))
        .add(k4[i].positionDerivative.multiply(1))
        .multiply(dt/6);
      
      // Update velocity: v(t+dt) = v(t) + dt/6 * (k1v + 2*k2v + 2*k3v + k4v)
      const velocityChange = k1[i].velocityDerivative.multiply(1)
        .add(k2[i].velocityDerivative.multiply(2))
        .add(k3[i].velocityDerivative.multiply(2))
        .add(k4[i].velocityDerivative.multiply(1))
        .multiply(dt/6);
      
      p.position = p.position.add(positionChange);
      p.velocity = p.velocity.add(velocityChange);
    }
  }

  // Evaluates the derivatives (velocities and accelerations) at the current state
  evaluateDerivatives(particles, derivatives, calcForces, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, globalDamping, gravityCoef) {
    // Clear forces
    for (let i = 0; i < particles.length; i++) {
      particles[i].force = new Vector3(0, 0, 0);
    }
    
    // Calculate forces based on current state
    calcForces(particles, edgeSprings, dihedralSprings, edgeK, dihedralK, damping, edgeCoef, gravityCoef);
    
    // Store derivatives for each particle
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      
      // Apply global damping to force
      const dampedForce = p.force.sub(p.velocity.multiply(globalDamping));
      
      // Store derivatives
      derivatives[i] = {
        positionDerivative: p.velocity.clone(), // dx/dt = v
        velocityDerivative: dampedForce.clone() // dv/dt = a = F/m (assuming mass = 1)
      };
    }
  }

  // Applies half-step changes to particles based on derivatives
  applyDerivativesHalfStep(particles, derivatives, halfDt, originalStates) {
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      const original = originalStates[i];
      
      // Apply half step: x = x0 + k*dt/2
      p.position = original.position.add(derivatives[i].positionDerivative.multiply(halfDt));
      p.velocity = original.velocity.add(derivatives[i].velocityDerivative.multiply(halfDt));
    }
  }

  // Applies full-step changes to particles based on derivatives
  applyDerivativesFullStep(particles, derivatives, dt, originalStates) {
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      const original = originalStates[i];
      
      // Apply full step: x = x0 + k*dt
      p.position = original.position.add(derivatives[i].positionDerivative.multiply(dt));
      p.velocity = original.velocity.add(derivatives[i].velocityDerivative.multiply(dt));
    }
  }

  // Restores particles to their original state (before the current RK4 step)
  restoreOriginalState(particles, originalStates) {
    for (let i = 0; i < particles.length; i++) {
      particles[i].position = originalStates[i].position.clone();
      particles[i].velocity = originalStates[i].velocity.clone();
    }
  }
  
  // Get all constants for tweaking
  getConstants() {
    return { ...this.constants };
  }
  
  // Set a specific constant
  setConstant(name, value) {
    if (name in this.constants) {
      this.constants[name] = value;
    }
  }
  
  // Get triangle positions for rendering
  getTriangles() {
    let avg = new Vector3();
    for (let i = 0; i < this.particles.length; i++) {
        avg = avg.add(this.particles[i].position);
    }
    avg = avg.multiply(1./this.particles.length);

    const trianglePositions = [];
    
    for (let i = 0; i < this.triangles.length; i++) {
      const t = this.triangles[i];
      const positions = [];
      
      for (let j = 0; j < 3; j++) {
        const p = this.particles[t.indices[j]].position.sub(avg);
        positions.push([p.x, p.y, p.z]); // Array format for three.js
      }
      
      trianglePositions.push(positions);
    }
    
    return trianglePositions;
  }
}

// Initialize the scene, camera, renderer, and controls
let scene, camera, renderer, controls, mesh;
let meshObject; // three.js object that will display our mesh
let positionAttribute; // Store the position attribute for updates

function init() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  // Create camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 3;

  // Create renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Add lights
  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);

  const directionalLight2 = new THREE.DirectionalLight(0xff0000, 0.8);
  directionalLight2.position.set(-1, -1, 1);
  scene.add(directionalLight2);

  // Create orbit controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.25;

  // Create our mesh
  mesh = new Mesh();
  mesh.init(50);
  createMeshObject();

  // Set up GUI
  setupGUI();

  // Add event listener for the step button
  document.getElementById('stepButton').addEventListener('click', () => {
    if (mesh.step()) {
      updateMeshObject();
    }
  });

  // Handle window resize
  window.addEventListener('resize', onWindowResize);

  // Start animation loop
  animate();
}

function createMeshObject() {
  // Remove existing mesh object if any
  if (meshObject) {
    scene.remove(meshObject);
  }

  // Create a new geometry and material
  const geometry = new THREE.BufferGeometry();
  const material = new THREE.MeshLambertMaterial({
    color: 0xffffff,
    side: THREE.DoubleSide
  });

  // Get triangles from our mesh
  const triangles = mesh.getTriangles();

  // Calculate the total number of vertices
  const vertexCount = triangles.length * 3;
  
  // Create position buffer with fixed size based on triangle count
  const positionBuffer = new Float32Array(vertexCount * 3);
  
  // Fill the buffer with initial positions
  updateVertexPositions(positionBuffer, triangles);
  
  // Create and store the position attribute
  positionAttribute = new THREE.BufferAttribute(positionBuffer, 3);
  geometry.setAttribute('position', positionAttribute);

  // Compute normals for proper lighting
  geometry.computeVertexNormals();

  // Create the mesh object and add it to the scene
  meshObject = new THREE.Mesh(geometry, material);
  scene.add(meshObject);
}

// Separate function to update vertex positions in the existing buffer
function updateVertexPositions(buffer, triangles) {
  let offset = 0;
  for (let i = 0; i < triangles.length; i++) {
    const triangle = triangles[i];
    for (let j = 0; j < 3; j++) {
      const point = triangle[j];
      buffer[offset++] = point[0];
      buffer[offset++] = point[1];
      buffer[offset++] = point[2];
    }
  }
  return buffer;
}

function updateMeshObject() {
  // Get triangles from our mesh
  const triangles = mesh.getTriangles();
  
  // Update the existing buffer with new positions
  updateVertexPositions(positionAttribute.array, triangles);
  
  // Mark the attribute as needing an update
  positionAttribute.needsUpdate = true;
  
  // Compute normals for proper lighting
  meshObject.geometry.computeVertexNormals();
}

function setupGUI() {
  const gui = new dat.GUI();
  const constants = mesh.getConstants();

  // Add controls for each constant
  for (const name in constants) {
    const value = constants[name];
    
    // Different control based on value type
    if (typeof value === 'boolean') {
      gui.add(constants, name).onChange(value => {
        mesh.setConstant(name, value);
        updateMeshObject();
      });
    } else if (typeof value === 'number') {
      // Different ranges based on parameter
      let min, max, step;
      
      if (name === 'iterations') {
        min = 1;
        max = 10;
        step = 1;
      } else if (name === 'edgeSpringConstant' || name === 'dihedralSpringConstant') {
        min = 0;
        max = 30;
        step = 0.1;
      } else if (name === 'edgeCoef' || name === 'gravityCoef') {
        min = 0;
        max = 5;
        step = 0.1;
      } else {
        min = 0;
        max = 1;
        step = 0.01;
      }
      
      gui.add(constants, name, min, max, step).onChange(value => {
        mesh.setConstant(name, value);
        updateMeshObject();
      });
    }
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);

  if (mesh.step()) {
    updateMeshObject();
  }
}

// Start the application
init();
</script>
</body>
</html>
